## SagaとEvent Sourcingシナリオ

### 組み合わせることによる原子性

#### 順序
1. Sagaオーケストレータにより, Sagaコマンドのディスパッチ.
2. Participantはそのハンドラを呼びだして, Repository層に該当するのが`Event Store DB`の発行API呼び出しなどになる.この時, (必要な場合)単なるドメインイベントの発行と`SagaReplyRequested`イベントを同時に発行する.
   1. ドメインイベントをサブスクライブしているのは関連するクエリサービス.これは, 簡単な検証などでイベントとしてレコードを残さない場合もある.
   2. `SagaReplyRequested`は, 同一サービス内での購読を行っており, このハンドラが呼ばれるとSagaのコマンドリプライチャネルに対して, Replyを送信する.さらに, このイベントのIDは(Sagaで呼ばれた)メッセージIDを利用することで, このメッセージに対する応答を一回だけにすることを保証できる.(ただし, Event Storeによってはもとから`exactly once`が保証されている場合もある, イベントストアにPostgres, それをCDCを経由したKafkaを利用して, イベントの発行・購読を行う場合はこれが必須.)

#### 考慮点
- `2`で2種類(1種類の場合もある)のイベントの発行をアトミックに行う必要がある.イベントストアにそれを保証できるものを利用していれば考慮する必要はないが, `Event Store DB`へのAPIとなると, この保証は難しくなる.

#### 対策

##### パターン1: Event Store DBでのバッチ処理
> AppendToStream takes a collection of , which allows you to save more than one event in a single batch.EventData
という記載があり, Batch処理が可能であるとのこと.これが意図するのが, 複数イベントの原子性を意味するものなのかはまだ未検証.

> コードリーディングが複数の実検証を行う必要あり.

##### パターン2: 逆順での実装
- Sagaハンドラが呼び出すRepository層の呼び出しは, `Event Store DB`の発行API呼び出しではなく, PostgresのOutboxテーブルへの保存とする.(Kafka+CDCを利用したイベント発行+SagaReply).ここでは, PostgresなどACID対応のデータベースを利用するため, 二つのコマンド発行に対する原子性を保証できる.
  - ドメインイベントをサブスクライブしているクエリサービスは, Kafkaからのイベントを購読しているわけではなく, Event Store DBのイベントを購読しているため, Kafkaにパブリッシュされたドメインイベントは同一(この)サービスが購読を行い, Event Store DBのAPI呼び出しを行う.成功した場合のみ, Kafkaでのオフセットをコミットすることで実現可能.
  - `SagaReplyRequested`はそのまま, Orchestratorに購読させる.

#### パターン3: 最低限の順序考慮
- [順序](#順序)での`2`において, DomainEventの発行->`SagaReplyRequested`イベントの発行の順序で行う.
- DomainEventの発行が成功したシナリオ.
  - `SagaReplyRequested`イベントが成功すると, そのままでok.
  - `SagaReplyRequested`イベントが失敗すると, DomainEventでの補償処理イベントの発行.
- DomainEventの発行が失敗したシナリオ.
  - DomainEvent発行のリプライもしくは失敗応答.
- これが逆順であれば, すでにReplyが送信されているため, 整合性が保証されない.ただし, この順序であれば補償処理が送信可能である.

### Saga内での検証
> 検証などについては, 現在のステートを必要とする場面が多いが, コマンドサービスはそのステートを自身のサービス内(もしくはその保有するデータベース)には直接的に保存していない.

#### コマンドサービスによるクエリサービス呼び出し

以下のような問題点がある.

1. 整合性が取れないことが多い.
2. 相互依存の関係を作ってしまう.

#### 一時対策
1. リードストアがほぼリアルタイムで更新される場合のみ採用.
2. 事前検証を別サービスで実装.

#### 対策
- Event Storeなど自身の保持するイベントストアを利用する.Event Storeなどの専用のストアを利用することで, イベントのリプライが簡単を簡単に行うことができ, 最新のステートへもアクセスできる.
- Redisなどでキャッシュを取ることでパフォーマンスの向上にもつながる.これは, イベントストアレコードのイミュータブル性を利用したものであり, Event Storeの読み取りを前回の続きから行うだけで実現可能であり, サブスクライブしているわけではないので, 必要の時に現在のステートを再現できる上にパフォーマンスを落とさずに可能.このキャッシュの保存は, 呼ばれた際にキャッシュを取っていく方法もあれば, 定期的に実行することも可能.